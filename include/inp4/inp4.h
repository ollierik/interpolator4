/******************************************************************************
interpolator4.h

Copyright 2023 Olli Erik Keskinen

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
******************************************************************************/

#ifndef INP4_H
#define INP4_H

#include <math.h>

/************
 ** COMMON **
 ***********/

#ifndef INP4_STATE_ENUM
#define INP4_STATE_ENUM
typedef enum {
    Inp4State_Done = 0,
    Inp4State_Init,
    Inp4State_SrcDepleted,
    Inp4State_DstDepleted,
} Inp4State;
#endif // INP4_STATE_ENUM

#ifndef INP4_CTX_SIZE
#   define INP4_CTX_SIZE 9
#endif

/********************
 ** FLOAT TO FLOAT **
 ********************/

/* floor and ceil flavours are determined by the position type */
#ifdef INP4FF_USE_FLOAT32_POS
    typedef float t_inp4ff_pos;
#   define INP4FF_FLOOR floorf
#   define INP4FF_CEIL  ceilf
#else
    typedef double t_inp4ff_pos;
#   define INP4FF_FLOOR floor
#   define INP4FF_CEIL  ceil 
#endif // INP4FF_USE_FLOAT32_POS

typedef float t_inp4ff_src;
typedef float t_inp4ff_dst;


typedef struct {
    Inp4State state;                        /* both src and dst can't deplete on the same pass.
                                               src depletion takes priority */
    int num_remaining;                      /* number of samples total to interpolate */
    int dst_index;                          /* dst output index, gets reset with every dst depletion */
    int context_index;                      /* index of the next free slot */
    int context_position;                   /* position of the first context element */
    t_inp4ff_pos position;                  /* local position, gets reset with every src depletion */
    t_inp4ff_src context [INP4_CTX_SIZE];   /* overlap context memory */
} inp4ff;


static void inp4ff_init(inp4ff* interp, int num_to_write, t_inp4ff_src initial_state)
{
    interp->state = Inp4State_Init;
    interp->num_remaining = num_to_write;
    interp->dst_index = 0;
    interp->context_index = 1;
    interp->context_position = -1;
    interp->position = 0.0;
    interp->context[0] = initial_state;
}

static inp4ff inp4ff_create(int num_to_write, t_inp4ff_pos initial_state)
{
    inp4ff interp;
    inp4ff_init(&interp, num_to_write, initial_state);
    return interp;
}


static t_inp4ff_dst  inp4ff__cubic_interp       (const t_inp4ff_src* x, t_inp4ff_pos fract);
static int           inp4ff__push_to_context    (inp4ff* interp, const t_inp4ff_src* src, int nsrc);
static int           inp4ff__read_from_context  (inp4ff* interp, t_inp4ff_dst* dst, t_inp4ff_pos rate, int n);
static void          inp4ff__read_from_src      (inp4ff* interp, t_inp4ff_dst* dst, const t_inp4ff_src* src, t_inp4ff_pos rate, int n);
static void          inp4ff__post_process       (inp4ff* interp, const t_inp4ff_src* src, int nsrc);

static void inp4ff_process(inp4ff* interp, t_inp4ff_dst* dst, int ndst, const t_inp4ff_src* src, int nsrc, t_inp4ff_pos rate)
{
    int n, last_index;

    /* If we're not continuing with the same src */
    if (interp->state != Inp4State_DstDepleted) {
        inp4ff__push_to_context(interp, src, nsrc);
    }
    
    /* Clear out old state flags */
    interp->state = Inp4State_Done;
    
    /* n is how many samples we may at most write to dst */
    n = ndst - interp->dst_index;
    
    if (n < interp->num_remaining) {

        /* dst is shorter than the number of requested samples */
        interp->state = Inp4State_DstDepleted;
    } else {

        /* dst is equal or too long, truncate */
        n = interp->num_remaining;
    }
    
    n = inp4ff__read_from_context(interp, dst, rate, n);
    
    /* Reading from context may have depleted all available space in dst. */
    if (n > 0) {
        
        /* Check if we will overflow, i.e. if src doesn't have enough samples
           available. */
        last_index = (int)(interp->position + n * rate);
        
        if (last_index > nsrc - 3) {
            
            /* src is going to get depleted with this call */
            interp->state = Inp4State_SrcDepleted;
            
            /* Adjust how many samples we're still able to write */
            n = (int)INP4FF_CEIL(((t_inp4ff_pos)(nsrc - 2) - interp->position) / rate);
        }
        
        /* do the main interpolation loop */
        inp4ff__read_from_src(interp, dst, src, rate, n);
    }
    
    inp4ff__post_process(interp, src, nsrc);
}


static t_inp4ff_dst inp4ff__cubic_interp(const t_inp4ff_src* x, t_inp4ff_pos fract)
{
    const t_inp4ff_dst x21_diff = x[2] - x[1];
    const t_inp4ff_dst c = (x[3] - x[0] - (t_inp4ff_dst)(3.0) * x21_diff) * fract
                           + (x[3] + (t_inp4ff_dst)(2.0) * x[0] - (t_inp4ff_dst)(3.0) * x[1]);
    
    const t_inp4ff_dst value = x[1] + fract * (x21_diff - (t_inp4ff_dst)(0.1666667) * ((t_inp4ff_dst)(1.0) - fract) * c);
    
    /*
    printf("%i: [%.20f, %.20f, %.20f, %.20f] (fract: %.20f) -> %.20f\n", interp_counter++, x[0], x[1], x[2], x[3], fract, value);
     */

    return value;
}

static int inp4ff__push_to_context(inp4ff* interp, const t_inp4ff_src* src, int nsrc)
{
    int i, j, m;

    /* We're either starting up or continuing with a new block. Copy
        newly available samples to the end of the context buffer. */
    m = nsrc < 3 ? nsrc : 3;
    
    for (i = 0; i < m; ++i) {

        /* If we're about to overflow, shift tail to the start of
            the context. This is a fairly unlikely case. */
        if (interp->context_index == INP4_CTX_SIZE) {

            for (j = 0; j < 5; ++j) {
                interp->context[j] = interp->context[interp->context_index - 5 + j];
            }
            interp->context_index = 5;
            interp->context_position += INP4_CTX_SIZE - 5;
        }
            
        interp->context[interp->context_index++] = src[i];
    }
}
    
static int inp4ff__read_from_context(inp4ff* interp, t_inp4ff_dst* dst, t_inp4ff_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop */

    int ipos, index;
    t_inp4ff_pos fract, pos;
    const int maxpos = interp->context_position + interp->context_index - 3;

    pos = interp->position;
    dst = dst + interp->dst_index; /* dst is incremented as ptr */

    ipos = (int)(INP4FF_FLOOR(interp->position));
    
    while (ipos <= maxpos && n > 0)
    {
        index = ipos - interp->context_position - 1;
        fract = pos - ipos;
        
        *dst++ = inp4ff__cubic_interp(&interp->context[index], fract);
        
        pos += rate;
        n--;
        ipos = (int)(INP4FF_FLOOR(pos));
    }
    num_read = num_read - n;

    /* store */
    interp->position = pos;
    interp->num_remaining -= num_read;
    interp->dst_index += num_read;

    return n;
}

static void inp4ff__read_from_src(inp4ff* interp, t_inp4ff_dst* dst, const t_inp4ff_src* src, t_inp4ff_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop*/
    t_inp4ff_pos pos = interp->position;

    /* temps */
    int ipos, index;
    t_inp4ff_pos fract;

    dst = dst + interp->dst_index;

    while (n > 0) {

        ipos = (int)(pos);
        index = ipos - 1;
        fract = pos - ipos;
        
        *dst++ = inp4ff__cubic_interp(&src[index], fract);
        
        pos += rate;
        n--;
    }
    
    num_read -= n;

    /* store */
    interp->position = pos;
    interp->dst_index += num_read;
    interp->num_remaining -= num_read;
}

static void inp4ff__post_process(inp4ff* interp, const t_inp4ff_src* src, int nsrc)
{
    if (interp->state == Inp4State_SrcDepleted) {

        interp->position -= nsrc;
        
        /* Fill the context by copying the 2 last and by reading 3 new elements
           to the beginning of the context. If nsrc is not greater than we've
           already pushed all available samples before the interpolation. */
        if (nsrc > 3) {

            interp->context[0] = interp->context[interp->context_index - 2];
            interp->context[1] = interp->context[interp->context_index - 1];
            interp->context[2] = src[nsrc - 3];
            interp->context[3] = src[nsrc - 2];
            interp->context[4] = src[nsrc - 1];
            
            interp->context_index = 5;
            interp->context_position = -5;
            
        } else {
            interp->context_position -= nsrc;
        }
    }
    else if (interp->state == Inp4State_DstDepleted)
    {
        interp->dst_index = 0;
    }
}



/*********************
 ** DOUBLE TO FLOAT **
 *********************/

/* floor and ceil flavours are determined by the position type */
#ifdef INP4FD_USE_FLOAT32_POS
    typedef float t_inp4fd_pos;
#   define INP4FD_FLOOR floorf
#   define INP4FD_CEIL  ceilf
#else
    typedef double t_inp4fd_pos;
#   define INP4FD_FLOOR floor
#   define INP4FD_CEIL  ceil 
#endif // INP4FD_USE_FLOAT32_POS

typedef float t_inp4fd_src;
typedef float t_inp4fd_dst;


typedef struct {
    Inp4State state;                             /* both src and dst can't deplete on the same pass.
                                                       src depletion takes priority */
    int num_remaining;                              /* number of samples total to interpolate */
    int dst_index;                                  /* dst output index, gets reset with every dst depletion */
    int context_index;                              /* index of the next free slot */
    int context_position;                           /* position of the first context element */
    t_inp4fd_pos position;                         /* local position, gets reset with every src depletion */
    t_inp4fd_src context [INP4_CTX_SIZE];   /* overlap context memory */
} inp4fd;


static void inp4fd_init(inp4fd* interp, int num_to_write, t_inp4fd_src initial_state)
{
    interp->state = Inp4State_Init;
    interp->num_remaining = num_to_write;
    interp->dst_index = 0;
    interp->context_index = 1;
    interp->context_position = -1;
    interp->position = 0.0;
    interp->context[0] = initial_state;
}

static inp4fd inp4fd_create(int num_to_write, t_inp4fd_pos initial_state)
{
    inp4fd interp;
    inp4fd_init(&interp, num_to_write, initial_state);
    return interp;
}

static t_inp4fd_dst  inp4fd__cubic_interp       (const t_inp4fd_src* x, t_inp4fd_pos fract);
static int           inp4fd__push_to_context    (inp4fd* interp, const t_inp4fd_src* src, int nsrc);
static int           inp4fd__read_from_context  (inp4fd* interp, t_inp4fd_dst* dst, t_inp4fd_pos rate, int n);
static void          inp4fd__read_from_src      (inp4fd* interp, t_inp4fd_dst* dst, const t_inp4fd_src* src, t_inp4fd_pos rate, int n);
static void          inp4fd__post_process       (inp4fd* interp, const t_inp4fd_src* src, int nsrc);

static void inp4fd_process(inp4fd* interp, t_inp4fd_dst* dst, int ndst, const t_inp4fd_src* src, int nsrc, t_inp4fd_pos rate)
{
    int n, last_index;

    /* If we're not continuing with the same src */
    if (interp->state != Inp4State_DstDepleted) {
        inp4fd__push_to_context(interp, src, nsrc);
    }
    
    /* Clear out old state flags */
    interp->state = Inp4State_Done;
    
    /* n is how many samples we may at most write to dst */
    n = ndst - interp->dst_index;
    
    if (n < interp->num_remaining) {

        /* dst is shorter than the number of requested samples */
        interp->state = Inp4State_DstDepleted;
    } else {

        /* dst is equal or too long, truncate */
        n = interp->num_remaining;
    }
    
    n = inp4fd__read_from_context(interp, dst, rate, n);
    
    /* Reading from context may have depleted all available space in dst. */
    if (n > 0) {
        
        /* Check if we will overflow, i.e. if src doesn't have enough samples
           available. */
        last_index = (int)(interp->position + n * rate);
        
        if (last_index > nsrc - 3) {
            
            /* src is going to get depleted with this call */
            interp->state = Inp4State_SrcDepleted;
            
            /* Adjust how many samples we're still able to write */
            n = (int)INP4FD_CEIL(((t_inp4fd_pos)(nsrc - 2) - interp->position) / rate);
        }
        
        /* do the main interpolation loop */
        inp4fd__read_from_src(interp, dst, src, rate, n);
    }
    
    inp4fd__post_process(interp, src, nsrc);
}


static t_inp4fd_dst inp4fd__cubic_interp(const t_inp4fd_src* x, t_inp4fd_pos fract)
{
    const t_inp4fd_dst x21_difd = x[2] - x[1];
    const t_inp4fd_dst c = (x[3] - x[0] - (t_inp4fd_dst)(3.0) * x21_difd) * fract
                           + (x[3] + (t_inp4fd_dst)(2.0) * x[0] - (t_inp4fd_dst)(3.0) * x[1]);
    
    const t_inp4fd_dst value = x[1] + fract * (x21_difd - (t_inp4fd_dst)(0.1666667) * ((t_inp4fd_dst)(1.0) - fract) * c);
    
    /*
    printf("%i: [%.20f, %.20f, %.20f, %.20f] (fract: %.20f) -> %.20f\n", interp_counter++, x[0], x[1], x[2], x[3], fract, value);
     */

    return value;
}

static int inp4fd__push_to_context(inp4fd* interp, const t_inp4fd_src* src, int nsrc)
{
    int i, j, m;

    /* We're either starting up or continuing with a new block. Copy
        newly available samples to the end of the context bufder. */
    m = nsrc < 3 ? nsrc : 3;
    
    for (i = 0; i < m; ++i) {

        /* If we're about to overflow, shift tail to the start of
            the context. This is a fairly unlikely case. */
        if (interp->context_index == INP4_CTX_SIZE) {

            for (j = 0; j < 5; ++j) {
                interp->context[j] = interp->context[interp->context_index - 5 + j];
            }
            interp->context_index = 5;
            interp->context_position += INP4_CTX_SIZE - 5;
        }
            
        interp->context[interp->context_index++] = src[i];
    }
}
    
static int inp4fd__read_from_context(inp4fd* interp, t_inp4fd_dst* dst, t_inp4fd_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop */

    int ipos, index;
    t_inp4fd_pos fract, pos;
    const int maxpos = interp->context_position + interp->context_index - 3;

    pos = interp->position;
    dst = dst + interp->dst_index; /* dst is incremented as ptr */

    ipos = (int)(INP4FD_FLOOR(interp->position));
    
    while (ipos <= maxpos && n > 0)
    {
        index = ipos - interp->context_position - 1;
        fract = pos - ipos;
        
        *dst++ = inp4fd__cubic_interp(&interp->context[index], fract);
        
        pos += rate;
        n--;
        ipos = (int)(INP4FD_FLOOR(pos));
    }
    num_read = num_read - n;

    /* store */
    interp->position = pos;
    interp->num_remaining -= num_read;
    interp->dst_index += num_read;

    return n;
}

static void inp4fd__read_from_src(inp4fd* interp, t_inp4fd_dst* dst, const t_inp4fd_src* src, t_inp4fd_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop*/
    t_inp4fd_pos pos = interp->position;

    /* temps */
    int ipos, index;
    t_inp4fd_pos fract;

    dst = dst + interp->dst_index;

    while (n > 0) {

        ipos = (int)(pos);
        index = ipos - 1;
        fract = pos - ipos;
        
        *dst++ = inp4fd__cubic_interp(&src[index], fract);
        
        pos += rate;
        n--;
    }
    
    num_read -= n;

    /* store */
    interp->position = pos;
    interp->dst_index += num_read;
    interp->num_remaining -= num_read;
}

static void inp4fd__post_process(inp4fd* interp, const t_inp4fd_src* src, int nsrc)
{
    if (interp->state == Inp4State_SrcDepleted) {

        interp->position -= nsrc;
        
        /* Fill the context by copying the 2 last and by reading 3 new elements
           to the beginning of the context. If nsrc is not greater than we've
           already pushed all available samples before the interpolation. */
        if (nsrc > 3) {

            interp->context[0] = interp->context[interp->context_index - 2];
            interp->context[1] = interp->context[interp->context_index - 1];
            interp->context[2] = src[nsrc - 3];
            interp->context[3] = src[nsrc - 2];
            interp->context[4] = src[nsrc - 1];
            
            interp->context_index = 5;
            interp->context_position = -5;
            
        } else {
            interp->context_position -= nsrc;
        }
    }
    else if (interp->state == Inp4State_DstDepleted)
    {
        interp->dst_index = 0;
    }
}


/*********************
 ** FLOAT TO DOUBLE **
 *********************/


/* floor and ceil flavours are determined by the position type */
#ifdef INP4DF_USE_FLOAT32_POS
    typedef float t_inp4df_pos;
#   define INP4DF_FLOOR floorf
#   define INP4DF_CEIL  ceilf
#else
    typedef double t_inp4df_pos;
#   define INP4DF_FLOOR floor
#   define INP4DF_CEIL  ceil 
#endif // INP4DF_USE_FLOAT32_POS

typedef float t_inp4df_src;
typedef float t_inp4df_dst;


typedef struct {
    Inp4State state;                             /* both src and dst can't deplete on the same pass.
                                                       src depletion takes priority */
    int num_remaining;                              /* number of samples total to interpolate */
    int dst_index;                                  /* dst output index, gets reset with every dst depletion */
    int context_index;                              /* index of the next free slot */
    int context_position;                           /* position of the first context element */
    t_inp4df_pos position;                         /* local position, gets reset with every src depletion */
    t_inp4df_src context [INP4_CTX_SIZE];   /* overlap context memory */
} inp4df;


static void inp4df_init(inp4df* interp, int num_to_write, t_inp4df_src initial_state)
{
    interp->state = Inp4State_Init;
    interp->num_remaining = num_to_write;
    interp->dst_index = 0;
    interp->context_index = 1;
    interp->context_position = -1;
    interp->position = 0.0;
    interp->context[0] = initial_state;
}

static inp4df inp4df_create(int num_to_write, t_inp4df_pos initial_state)
{
    inp4df interp;
    inp4df_init(&interp, num_to_write, initial_state);
    return interp;
}


static t_inp4df_dst  inp4df__cubic_interp       (const t_inp4df_src* x, t_inp4df_pos fract);
static int           inp4df__push_to_context    (inp4df* interp, const t_inp4df_src* src, int nsrc);
static int           inp4df__read_from_context  (inp4df* interp, t_inp4df_dst* dst, t_inp4df_pos rate, int n);
static void          inp4df__read_from_src      (inp4df* interp, t_inp4df_dst* dst, const t_inp4df_src* src, t_inp4df_pos rate, int n);
static void          inp4df__post_process       (inp4df* interp, const t_inp4df_src* src, int nsrc);

static void inp4df_process(inp4df* interp, t_inp4df_dst* dst, int ndst, const t_inp4df_src* src, int nsrc, t_inp4df_pos rate)
{
    int n, last_index;

    /* If we're not continuing with the same src */
    if (interp->state != Inp4State_DstDepleted) {
        inp4df__push_to_context(interp, src, nsrc);
    }
    
    /* Clear out old state flags */
    interp->state = Inp4State_Done;
    
    /* n is how many samples we may at most write to dst */
    n = ndst - interp->dst_index;
    
    if (n < interp->num_remaining) {

        /* dst is shorter than the number of requested samples */
        interp->state = Inp4State_DstDepleted;
    } else {

        /* dst is equal or too long, truncate */
        n = interp->num_remaining;
    }
    
    n = inp4df__read_from_context(interp, dst, rate, n);
    
    /* Reading from context may have depleted all available space in dst. */
    if (n > 0) {
        
        /* Check if we will overflow, i.e. if src doesn't have enough samples
           available. */
        last_index = (int)(interp->position + n * rate);
        
        if (last_index > nsrc - 3) {
            
            /* src is going to get depleted with this call */
            interp->state = Inp4State_SrcDepleted;
            
            /* Adjust how many samples we're still able to write */
            n = (int)INP4DF_CEIL(((t_inp4df_pos)(nsrc - 2) - interp->position) / rate);
        }
        
        /* do the main interpolation loop */
        inp4df__read_from_src(interp, dst, src, rate, n);
    }
    
    inp4df__post_process(interp, src, nsrc);
}


static t_inp4df_dst inp4df__cubic_interp(const t_inp4df_src* x, t_inp4df_pos fract)
{
    const t_inp4df_dst x21_didf = x[2] - x[1];
    const t_inp4df_dst c = (x[3] - x[0] - (t_inp4df_dst)(3.0) * x21_didf) * fract
                           + (x[3] + (t_inp4df_dst)(2.0) * x[0] - (t_inp4df_dst)(3.0) * x[1]);
    
    const t_inp4df_dst value = x[1] + fract * (x21_didf - (t_inp4df_dst)(0.1666667) * ((t_inp4df_dst)(1.0) - fract) * c);
    
    /*
    printf("%i: [%.20f, %.20f, %.20f, %.20f] (fract: %.20f) -> %.20f\n", interp_counter++, x[0], x[1], x[2], x[3], fract, value);
     */

    return value;
}

static int inp4df__push_to_context(inp4df* interp, const t_inp4df_src* src, int nsrc)
{
    int i, j, m;

    /* We're either starting up or continuing with a new block. Copy
        newly available samples to the end of the context budfer. */
    m = nsrc < 3 ? nsrc : 3;
    
    for (i = 0; i < m; ++i) {

        /* If we're about to overflow, shift tail to the start of
            the context. This is a fairly unlikely case. */
        if (interp->context_index == INP4_CTX_SIZE) {

            for (j = 0; j < 5; ++j) {
                interp->context[j] = interp->context[interp->context_index - 5 + j];
            }
            interp->context_index = 5;
            interp->context_position += INP4_CTX_SIZE - 5;
        }
            
        interp->context[interp->context_index++] = src[i];
    }
}
    
static int inp4df__read_from_context(inp4df* interp, t_inp4df_dst* dst, t_inp4df_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop */

    int ipos, index;
    t_inp4df_pos fract, pos;
    const int maxpos = interp->context_position + interp->context_index - 3;

    pos = interp->position;
    dst = dst + interp->dst_index; /* dst is incremented as ptr */

    ipos = (int)(INP4DF_FLOOR(interp->position));
    
    while (ipos <= maxpos && n > 0)
    {
        index = ipos - interp->context_position - 1;
        fract = pos - ipos;
        
        *dst++ = inp4df__cubic_interp(&interp->context[index], fract);
        
        pos += rate;
        n--;
        ipos = (int)(INP4DF_FLOOR(pos));
    }
    num_read = num_read - n;

    /* store */
    interp->position = pos;
    interp->num_remaining -= num_read;
    interp->dst_index += num_read;

    return n;
}

static void inp4df__read_from_src(inp4df* interp, t_inp4df_dst* dst, const t_inp4df_src* src, t_inp4df_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop*/
    t_inp4df_pos pos = interp->position;

    /* temps */
    int ipos, index;
    t_inp4df_pos fract;

    dst = dst + interp->dst_index;

    while (n > 0) {

        ipos = (int)(pos);
        index = ipos - 1;
        fract = pos - ipos;
        
        *dst++ = inp4df__cubic_interp(&src[index], fract);
        
        pos += rate;
        n--;
    }
    
    num_read -= n;

    /* store */
    interp->position = pos;
    interp->dst_index += num_read;
    interp->num_remaining -= num_read;
}

static void inp4df__post_process(inp4df* interp, const t_inp4df_src* src, int nsrc)
{
    if (interp->state == Inp4State_SrcDepleted) {

        interp->position -= nsrc;
        
        /* Fill the context by copying the 2 last and by reading 3 new elements
           to the beginning of the context. If nsrc is not greater than we've
           already pushed all available samples before the interpolation. */
        if (nsrc > 3) {

            interp->context[0] = interp->context[interp->context_index - 2];
            interp->context[1] = interp->context[interp->context_index - 1];
            interp->context[2] = src[nsrc - 3];
            interp->context[3] = src[nsrc - 2];
            interp->context[4] = src[nsrc - 1];
            
            interp->context_index = 5;
            interp->context_position = -5;
            
        } else {
            interp->context_position -= nsrc;
        }
    }
    else if (interp->state == Inp4State_DstDepleted)
    {
        interp->dst_index = 0;
    }
}

/*********************
 ** DOUBLE TO DOUBLE **
 *********************/


/* floor and ceil flavours are determined by the position type */
#ifdef INP4DD_USE_FLOAT32_POS
    typedef float t_inp4dd_pos;
#   define INP4DD_FLOOR floorf
#   define INP4DD_CEIL  ceilf
#else
    typedef double t_inp4dd_pos;
#   define INP4DD_FLOOR floor
#   define INP4DD_CEIL  ceil 
#endif // INP4DD_USE_FLOAT32_POS

typedef float t_inp4dd_src;
typedef float t_inp4dd_dst;


typedef struct {
    Inp4State state;                             /* both src and dst can't deplete on the same pass.
                                                       src depletion takes priority */
    int num_remaining;                              /* number of samples total to interpolate */
    int dst_index;                                  /* dst output index, gets reset with every dst depletion */
    int context_index;                              /* index of the next free slot */
    int context_position;                           /* position of the first context element */
    t_inp4dd_pos position;                         /* local position, gets reset with every src depletion */
    t_inp4dd_src context [INP4_CTX_SIZE];   /* overlap context memory */
} inp4dd;


static void inp4dd_init(inp4dd* interp, int num_to_write, t_inp4dd_src initial_state)
{
    interp->state = Inp4State_Init;
    interp->num_remaining = num_to_write;
    interp->dst_index = 0;
    interp->context_index = 1;
    interp->context_position = -1;
    interp->position = 0.0;
    interp->context[0] = initial_state;
}

static inp4dd inp4dd_create(int num_to_write, t_inp4dd_pos initial_state)
{
    inp4dd interp;
    inp4dd_init(&interp, num_to_write, initial_state);
    return interp;
}


static t_inp4dd_dst  inp4dd__cubic_interp       (const t_inp4dd_src* x, t_inp4dd_pos fract);
static int           inp4dd__push_to_context    (inp4dd* interp, const t_inp4dd_src* src, int nsrc);
static int           inp4dd__read_from_context  (inp4dd* interp, t_inp4dd_dst* dst, t_inp4dd_pos rate, int n);
static void          inp4dd__read_from_src      (inp4dd* interp, t_inp4dd_dst* dst, const t_inp4dd_src* src, t_inp4dd_pos rate, int n);
static void          inp4dd__post_process       (inp4dd* interp, const t_inp4dd_src* src, int nsrc);

static void inp4dd_process(inp4dd* interp, t_inp4dd_dst* dst, int ndst, const t_inp4dd_src* src, int nsrc, t_inp4dd_pos rate)
{
    int n, last_index;

    /* If we're not continuing with the same src */
    if (interp->state != Inp4State_DstDepleted) {
        inp4dd__push_to_context(interp, src, nsrc);
    }
    
    /* Clear out old state flags */
    interp->state = Inp4State_Done;
    
    /* n is how many samples we may at most write to dst */
    n = ndst - interp->dst_index;
    
    if (n < interp->num_remaining) {

        /* dst is shorter than the number of requested samples */
        interp->state = Inp4State_DstDepleted;
    } else {

        /* dst is equal or too long, truncate */
        n = interp->num_remaining;
    }
    
    n = inp4dd__read_from_context(interp, dst, rate, n);
    
    /* Reading from context may have depleted all available space in dst. */
    if (n > 0) {
        
        /* Check if we will overflow, i.e. if src doesn't have enough samples
           available. */
        last_index = (int)(interp->position + n * rate);
        
        if (last_index > nsrc - 3) {
            
            /* src is going to get depleted with this call */
            interp->state = Inp4State_SrcDepleted;
            
            /* Adjust how many samples we're still able to write */
            n = (int)INP4DD_CEIL(((t_inp4dd_pos)(nsrc - 2) - interp->position) / rate);
        }
        
        /* do the main interpolation loop */
        inp4dd__read_from_src(interp, dst, src, rate, n);
    }
    
    inp4dd__post_process(interp, src, nsrc);
}


static t_inp4dd_dst inp4dd__cubic_interp(const t_inp4dd_src* x, t_inp4dd_pos fract)
{
    const t_inp4dd_dst x21_didd = x[2] - x[1];
    const t_inp4dd_dst c = (x[3] - x[0] - (t_inp4dd_dst)(3.0) * x21_didd) * fract
                           + (x[3] + (t_inp4dd_dst)(2.0) * x[0] - (t_inp4dd_dst)(3.0) * x[1]);
    
    const t_inp4dd_dst value = x[1] + fract * (x21_didd - (t_inp4dd_dst)(0.1666667) * ((t_inp4dd_dst)(1.0) - fract) * c);
    
    /*
    printf("%i: [%.20f, %.20f, %.20f, %.20f] (fract: %.20f) -> %.20f\n", interp_counter++, x[0], x[1], x[2], x[3], fract, value);
     */

    return value;
}

static int inp4dd__push_to_context(inp4dd* interp, const t_inp4dd_src* src, int nsrc)
{
    int i, j, m;

    /* We're either starting up or continuing with a new block. Copy
        newly available samples to the end of the context budder. */
    m = nsrc < 3 ? nsrc : 3;
    
    for (i = 0; i < m; ++i) {

        /* If we're about to overflow, shift tail to the start of
            the context. This is a fairly unlikely case. */
        if (interp->context_index == INP4_CTX_SIZE) {

            for (j = 0; j < 5; ++j) {
                interp->context[j] = interp->context[interp->context_index - 5 + j];
            }
            interp->context_index = 5;
            interp->context_position += INP4_CTX_SIZE - 5;
        }
            
        interp->context[interp->context_index++] = src[i];
    }
}
    
static int inp4dd__read_from_context(inp4dd* interp, t_inp4dd_dst* dst, t_inp4dd_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop */

    int ipos, index;
    t_inp4dd_pos fract, pos;
    const int maxpos = interp->context_position + interp->context_index - 3;

    pos = interp->position;
    dst = dst + interp->dst_index; /* dst is incremented as ptr */

    ipos = (int)(INP4DD_FLOOR(interp->position));
    
    while (ipos <= maxpos && n > 0)
    {
        index = ipos - interp->context_position - 1;
        fract = pos - ipos;
        
        *dst++ = inp4dd__cubic_interp(&interp->context[index], fract);
        
        pos += rate;
        n--;
        ipos = (int)(INP4DD_FLOOR(pos));
    }
    num_read = num_read - n;

    /* store */
    interp->position = pos;
    interp->num_remaining -= num_read;
    interp->dst_index += num_read;

    return n;
}

static void inp4dd__read_from_src(inp4dd* interp, t_inp4dd_dst* dst, const t_inp4dd_src* src, t_inp4dd_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop*/
    t_inp4dd_pos pos = interp->position;

    /* temps */
    int ipos, index;
    t_inp4dd_pos fract;

    dst = dst + interp->dst_index;

    while (n > 0) {

        ipos = (int)(pos);
        index = ipos - 1;
        fract = pos - ipos;
        
        *dst++ = inp4dd__cubic_interp(&src[index], fract);
        
        pos += rate;
        n--;
    }
    
    num_read -= n;

    /* store */
    interp->position = pos;
    interp->dst_index += num_read;
    interp->num_remaining -= num_read;
}

static void inp4dd__post_process(inp4dd* interp, const t_inp4dd_src* src, int nsrc)
{
    if (interp->state == Inp4State_SrcDepleted) {

        interp->position -= nsrc;
        
        /* Fill the context by copying the 2 last and by reading 3 new elements
           to the beginning of the context. If nsrc is not greater than we've
           already pushed all available samples before the interpolation. */
        if (nsrc > 3) {

            interp->context[0] = interp->context[interp->context_index - 2];
            interp->context[1] = interp->context[interp->context_index - 1];
            interp->context[2] = src[nsrc - 3];
            interp->context[3] = src[nsrc - 2];
            interp->context[4] = src[nsrc - 1];
            
            interp->context_index = 5;
            interp->context_position = -5;
            
        } else {
            interp->context_position -= nsrc;
        }
    }
    else if (interp->state == Inp4State_DstDepleted)
    {
        interp->dst_index = 0;
    }
}

#endif /* INP4_H */ 
