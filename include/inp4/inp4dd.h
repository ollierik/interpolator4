/******************************************************************************
interpolator4.h

Copyright 2023 Olli Erik Keskinen

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
******************************************************************************/

#ifndef INP4DD_H
#define INP4DD_H

#include <math.h>

#ifndef INP4_STATE_ENUM
#define INP4_STATE_ENUM
typedef enum {
    Inp4State_Done = 0,
    Inp4State_Init,
    Inp4State_SrcDepleted,
    Inp4State_DstDepleted,
} Inp4State;
#endif // INP4_STATE_ENUM

#ifndef INP4DD_CTX_SIZE
#   define INP4DD_CTX_SIZE 9
#endif

/* floor and ceil flavours are determined by the position type */
#ifdef INP4DD_USE_FLOAT32_POS
    typedef float t_inp4dd_pos;
#   define INP4DD_FLOOR floorf
#   define INP4DD_CEIL  ceilf
#else
    typedef double t_inp4dd_pos;
#   define INP4DD_FLOOR floor
#   define INP4DD_CEIL  ceil 
#endif // INP4DD_USE_FLOAT32_POS

typedef float t_inp4dd_src;
typedef float t_inp4dd_dst;


typedef struct {
    Inp4State state;                             /* both src and dst can't deplete on the same pass.
                                                       src depletion takes priority */
    int num_remaining;                              /* number of samples total to interpolate */
    int dst_index;                                  /* dst output index, gets reset with every dst depletion */
    int context_index;                              /* index of the next free slot */
    int context_position;                           /* position of the first context element */
    t_inp4dd_pos position;                         /* local position, gets reset with every src depletion */
    t_inp4dd_src context [INP4DD_CTX_SIZE];   /* overlap context memory */
} inp4dd;


static void inp4dd_init(inp4dd* interp, int num_to_write, t_inp4dd_src initial_state)
{
    interp->state = Inp4State_Init;
    interp->num_remaining = num_to_write;
    interp->dst_index = 0;
    interp->context_index = 1;
    interp->context_position = -1;
    interp->position = 0.0;
    interp->context[0] = initial_state;
}

static inp4dd inp4dd_create(int num_to_write, t_inp4dd_pos initial_state)
{
    inp4dd interp;
    inp4dd_init(&interp, num_to_write, initial_state);
    return interp;
}


static t_inp4dd_dst  inp4dd__cubic_interp       (const t_inp4dd_src* x, t_inp4dd_pos fract);
static int           inp4dd__push_to_context    (inp4dd* interp, const t_inp4dd_src* src, int nsrc);
static int           inp4dd__read_from_context  (inp4dd* interp, t_inp4dd_dst* dst, t_inp4dd_pos rate, int n);
static void          inp4dd__read_from_src      (inp4dd* interp, t_inp4dd_dst* dst, const t_inp4dd_src* src, t_inp4dd_pos rate, int n);
static void          inp4dd__post_process       (inp4dd* interp, const t_inp4dd_src* src, int nsrc);

static void inp4dd_process(inp4dd* interp, t_inp4dd_dst* dst, int ndst, const t_inp4dd_src* src, int nsrc, t_inp4dd_pos rate)
{
    int n, last_index;

    /* If we're not continuing with the same src */
    if (interp->state != Inp4State_DstDepleted) {
        inp4dd__push_to_context(interp, src, nsrc);
    }
    
    /* Clear out old state flags */
    interp->state = Inp4State_Done;
    
    /* n is how many samples we may at most write to dst */
    n = ndst - interp->dst_index;
    
    if (n < interp->num_remaining) {

        /* dst is shorter than the number of requested samples */
        interp->state = Inp4State_DstDepleted;
    } else {

        /* dst is equal or too long, truncate */
        n = interp->num_remaining;
    }
    
    n = inp4dd__read_from_context(interp, dst, rate, n);
    
    /* Reading from context may have depleted all available space in dst. */
    if (n > 0) {
        
        /* Check if we will overflow, i.e. if src doesn't have enough samples
           available. */
        last_index = (int)(interp->position + n * rate);
        
        if (last_index > nsrc - 3) {
            
            /* src is going to get depleted with this call */
            interp->state = Inp4State_SrcDepleted;
            
            /* Adjust how many samples we're still able to write */
            n = (int)INP4DD_CEIL(((t_inp4dd_pos)(nsrc - 2) - interp->position) / rate);
        }
        
        /* do the main interpolation loop */
        inp4dd__read_from_src(interp, dst, src, rate, n);
    }
    
    inp4dd__post_process(interp, src, nsrc);
}


static t_inp4dd_dst inp4dd__cubic_interp(const t_inp4dd_src* x, t_inp4dd_pos fract)
{
    const t_inp4dd_dst x21_didd = x[2] - x[1];
    const t_inp4dd_dst c = (x[3] - x[0] - (t_inp4dd_dst)(3.0) * x21_didd) * fract
                           + (x[3] + (t_inp4dd_dst)(2.0) * x[0] - (t_inp4dd_dst)(3.0) * x[1]);
    
    const t_inp4dd_dst value = x[1] + fract * (x21_didd - (t_inp4dd_dst)(0.1666667) * ((t_inp4dd_dst)(1.0) - fract) * c);
    
    /*
    printf("%i: [%.20f, %.20f, %.20f, %.20f] (fract: %.20f) -> %.20f\n", interp_counter++, x[0], x[1], x[2], x[3], fract, value);
     */

    return value;
}

static int inp4dd__push_to_context(inp4dd* interp, const t_inp4dd_src* src, int nsrc)
{
    int i, j, m;

    /* We're either starting up or continuing with a new block. Copy
        newly available samples to the end of the context budder. */
    m = nsrc < 3 ? nsrc : 3;
    
    for (i = 0; i < m; ++i) {

        /* If we're about to overflow, shift tail to the start of
            the context. This is a fairly unlikely case. */
        if (interp->context_index == INP4DD_CTX_SIZE) {

            for (j = 0; j < 5; ++j) {
                interp->context[j] = interp->context[interp->context_index - 5 + j];
            }
            interp->context_index = 5;
            interp->context_position += INP4DD_CTX_SIZE - 5;
        }
            
        interp->context[interp->context_index++] = src[i];
    }
}
    
static int inp4dd__read_from_context(inp4dd* interp, t_inp4dd_dst* dst, t_inp4dd_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop */

    int ipos, index;
    t_inp4dd_pos fract, pos;
    const int maxpos = interp->context_position + interp->context_index - 3;

    pos = interp->position;
    dst = dst + interp->dst_index; /* dst is incremented as ptr */

    ipos = (int)(INP4DD_FLOOR(interp->position));
    
    while (ipos <= maxpos && n > 0)
    {
        index = ipos - interp->context_position - 1;
        fract = pos - ipos;
        
        *dst++ = inp4dd__cubic_interp(&interp->context[index], fract);
        
        pos += rate;
        n--;
        ipos = (int)(INP4DD_FLOOR(pos));
    }
    num_read = num_read - n;

    /* store */
    interp->position = pos;
    interp->num_remaining -= num_read;
    interp->dst_index += num_read;

    return n;
}

static void inp4dd__read_from_src(inp4dd* interp, t_inp4dd_dst* dst, const t_inp4dd_src* src, t_inp4dd_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop*/
    t_inp4dd_pos pos = interp->position;

    /* temps */
    int ipos, index;
    t_inp4dd_pos fract;

    dst = dst + interp->dst_index;

    while (n > 0) {

        ipos = (int)(pos);
        index = ipos - 1;
        fract = pos - ipos;
        
        *dst++ = inp4dd__cubic_interp(&src[index], fract);
        
        pos += rate;
        n--;
    }
    
    num_read -= n;

    /* store */
    interp->position = pos;
    interp->dst_index += num_read;
    interp->num_remaining -= num_read;
}

static void inp4dd__post_process(inp4dd* interp, const t_inp4dd_src* src, int nsrc)
{
    if (interp->state == Inp4State_SrcDepleted) {

        interp->position -= nsrc;
        
        /* Fill the context by copying the 2 last and by reading 3 new elements
           to the beginning of the context. If nsrc is not greater than we've
           already pushed all available samples before the interpolation. */
        if (nsrc > 3) {

            interp->context[0] = interp->context[interp->context_index - 2];
            interp->context[1] = interp->context[interp->context_index - 1];
            interp->context[2] = src[nsrc - 3];
            interp->context[3] = src[nsrc - 2];
            interp->context[4] = src[nsrc - 1];
            
            interp->context_index = 5;
            interp->context_position = -5;
            
        } else {
            interp->context_position -= nsrc;
        }
    }
    else if (interp->state == Inp4State_DstDepleted)
    {
        interp->dst_index = 0;
    }
}


#endif /* INP4DD_H */ 
