/******************************************************************************
interpolator4.h

Copyright 2023 Olli Erik Keskinen

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
******************************************************************************/

#ifndef INTERP4FF_H
#define INTERP4FF_H

#include <math.h>

typedef enum {
    Interp4State_Done = 0,
    Interp4State_Init,
    Interp4State_SrcDepleted,
    Interp4State_DstDepleted,
} Interp4State;

#ifndef INTERP4FF_CTX_SIZE
#   define INTERP4FF_CTX_SIZE 9
#endif

#ifdef INTERP4FF_USE_FLOAT32_POS
typedef float t_interp4ff_pos;
#else
typedef double t_interp4ff_pos;
#endif // INTERP4FF_USE_FLOAT32_POS

typedef float t_interp4ff_src;
typedef float t_interp4ff_dst;

typedef struct {
    Interp4State state;                             /* both src and dst can't deplete on the same pass.
                                                       src depletion takes priority */
    int num_remaining;                              /* number of samples total to interpolate */
    int dst_index;                                  /* dst output index, gets reset with every dst depletion */
    int context_index;                              /* index of the next free slot */
    int context_position;                           /* position of the first context element */
    t_interp4ff_pos position;                         /* local position, gets reset with every src depletion */
    t_interp4ff_src context [INTERP4FF_CTX_SIZE];   /* overlap context memory */
} interp4ff;

static void interp4ff_init(interp4ff* interp, int num_to_write, t_interp4ff_src initial_state)
{
    interp->state = Interp4State_Init;
    interp->num_remaining = num_to_write;
    interp->dst_index = 0;
    interp->context_index = 1;
    interp->context_position = -1;
    interp->position = 0.0;
    interp->context[0] = initial_state;
}

static interp4ff interp4ff_create(int num_to_write, float initial_state)
{
    interp4ff interp;
    interp4ff_init(&interp, num_to_write, initial_state);
    return interp;
}


static t_interp4ff_dst  interp4ff__cubic_interp     (const float* x, t_interp4ff_pos fract);
static int              interp4ff__push_to_context  (interp4ff* interp, const t_interp4ff_src* src, int nsrc);
static int              interp4ff__read_from_context(interp4ff* interp, float* dst, t_interp4ff_pos rate, int n);
static void             interp4ff__read_from_src    (interp4ff* interp, t_interp4ff_dst* dst, const t_interp4ff_src* src, t_interp4ff_pos rate, int n);
static void             interp4ff__post_process     (interp4ff* interp, int nsrc);

static void interp4ff_process(interp4ff* interp, t_interp4_dst* dst, int ndst, const t_interp4_src* src, int nsrc, t_interp4ff_pos rate)
{
    int n, last_index;

    /* If we're not continuing with the same src */
    if (interp->state != Interp4State_DstDepleted) {
        interp4ff__push_to_context(interp, src, nsrc);
    }
    
    /* Clear out old state flags */
    interp->state = Interp4State_Done;
    
    /* n is how many samples we may at most write to dst */
    n = ndst - interp->dst_index;
    
    if (n < interp->num_remaining) {

        /* dst is shorter than the number of requested samples */
        interp->state = Interp4State_DstDepleted;
    } else {

        /* dst is equal or too long, truncate */
        n = interp->num_remaining;
    }
    
    n = interp4ff__read_from_context(interp, dst, rate, n);
    
    /* Reading from context may have depleted all available space in dst. */
    if (n > 0) {
        
        /* Check if we will overflow, i.e. if src doesn't have enough samples
           available. */
        last_index = (int)(interp->position + n * rate);
        
        if (last_index > nsrc - 3) {
            
            /* src is going to get depleted with this call */
            interp->state = Interp4State_SrcDepleted;
            
            /* Adjust how many samples we're still able to write */
            n = (int)ceil(((float)(nsrc - 2) - interp->position) / rate);
        }
        
        /* do the main interpolation loop */
        interp4ff__read_from_src(interp, dst, src, rate, n);
    }
    
    interp4ff__post_process(interp, nsrc);
}


static float interp4ff__cubic_interp(const t_interp4ff_src* x, float fract)
{
    const float x21_diff = x[2] - x[1];
    const float common_term = (x[3] - x[0] - (float)(3.0) * x21_diff) * fract
                        + (x[3] + (float)(2.0) * x[0] - (float)(3.0) * x[1]);
    
    const float value = x[1] + fract * (x21_diff - (float)(0.1666667) * ((float)(1.0) - fract) * common_term);
    
    /*
    printf("%i: [%.20f, %.20f, %.20f, %.20f] (fract: %.20f) -> %.20f\n", interp_counter++, x[0], x[1], x[2], x[3], fract, value);
     */

    return value;
}

static int interp4ff__push_to_context(interp4ff* interp, const float* src, int nsrc)
{
    int i, j, m;

    /* We're either starting up or continuing with a new block. Copy
        newly available samples to the end of the context buffer. */
    m = nsrc < 3 ? nsrc : 3;
    
    for (i = 0; i < m; ++i) {

        /* If we're about to overflow, shift tail to the start of
            the context. This is a fairly unlikely case. */
        if (interp->context_index == INTERP4FF_CTX_SIZE) {

            for (j = 0; j < 5; ++j) {
                interp->context[j] = interp->context[interp->context_index - 5 + j];
            }
            interp->context_index = 5;
            interp->context_position += INTERP4FF_CTX_SIZE - 5;
        }
            
        interp->context[interp->context_index++] = src[i];
    }
}
    
static int interp4ff__read_from_context(interp4ff* interp, float* dst, t_interp4ff_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop */

    int ipos, index;
    float fract, pos;
    const int maxpos = interp->context_position + interp->context_index - 3;

    pos = interp->position;
    dst = dst + interp->dst_index; /* dst is incremented as ptr */

    ipos = (int)(floor(interp->position));
    
    while (ipos <= maxpos && n > 0)
    {
        index = ipos - interp->context_position - 1;
        fract = pos - ipos;
        
        *dst++ = interp4ff__cubic_interp(&interp->context[index], fract);
        
        pos += rate;
        n--;
        ipos = (int)(floor(pos));
    }
    num_read = num_read - n;

    /* store */
    interp->position = pos;
    interp->num_remaining -= num_read;
    interp->dst_index += num_read;

    return n;
}

static void interp4ff__read_from_src(interp4ff* interp, float* dst, const float* src, t_interp4ff_pos rate, int n)
{
    int num_read = n; /* init to n, substract after loop*/
    float pos = interp->position;

    /* temps */
    int ipos, index;
    float fract;

    dst = dst + interp->dst_index;

    while (n > 0) {

        ipos = (int)(pos);
        index = ipos - 1;
        fract = pos - ipos;
        
        *dst++ = interp4f__cubic_interp(&src[index], fract);
        
        pos += rate;
        n--;
    }
    
    num_read -= n;

    /* store */
    interp->position = pos;
    interp->dst_index += num_read;
    interp->num_remaining -= num_read;
}

static void interp4ff__post_process(interp4ff* interp, int nsrc)
{
    if (interp->state == Interp4State_SrcDepleted) {

        interp->position -= nsrc;
        
        /* Fill the context by copying the 2 last and by reading 3 new elements
           to the beginning of the context. If nsrc is not greater than we've
           already pushed all available samples before the interpolation. */
        if (nsrc > 3) {

            interp->context[0] = interp->context[interp->context_index - 2];
            interp->context[1] = interp->context[interp->context_index - 1];
            interp->context[2] = src[nsrc - 3];
            interp->context[3] = src[nsrc - 2];
            interp->context[4] = src[nsrc - 1];
            
            interp->context_index = 5;
            interp->context_position = -5;
            
        } else {
            interp->context_position -= nsrc;
        }
    }
    else if (interp->state == Interp4State_DstDepleted)
    {
        interp->dst_index = 0;
    }
}


#endif /* INTERP4FF_H */ 
